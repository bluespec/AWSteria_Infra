//
// Generated by Bluespec Compiler, version 2021.07 (build 4cac6eb)
//
//
// Ports:
// Name                         I/O  size props
// axi4L_S_awready                O     1 reg
// axi4L_S_wready                 O     1 reg
// axi4L_S_bvalid                 O     1 reg
// axi4L_S_bresp                  O     2 reg
// axi4L_S_arready                O     1 reg
// axi4L_S_rvalid                 O     1 reg
// axi4L_S_rresp                  O     2 reg
// axi4L_S_rdata                  O    32 reg
// ip_enable                      O     1 reg
// RDY_ip_enable                  O     1 const
// CLK_clock_for_app              O     1 const
// CLK_GATE_clock_for_app         O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi4L_S_awvalid                I     1
// axi4L_S_awaddr                 I    32 reg
// axi4L_S_awprot                 I     3 reg
// axi4L_S_wvalid                 I     1
// axi4L_S_wdata                  I    32 reg
// axi4L_S_wstrb                  I     4 reg
// axi4L_S_bready                 I     1
// axi4L_S_arvalid                I     1
// axi4L_S_araddr                 I    32 reg
// axi4L_S_arprot                 I     3 reg
// axi4L_S_rready                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDRM(CLK,
	     RST_N,

	     axi4L_S_awvalid,
	     axi4L_S_awaddr,
	     axi4L_S_awprot,

	     axi4L_S_awready,

	     axi4L_S_wvalid,
	     axi4L_S_wdata,
	     axi4L_S_wstrb,

	     axi4L_S_wready,

	     axi4L_S_bvalid,

	     axi4L_S_bresp,

	     axi4L_S_bready,

	     axi4L_S_arvalid,
	     axi4L_S_araddr,
	     axi4L_S_arprot,

	     axi4L_S_arready,

	     axi4L_S_rvalid,

	     axi4L_S_rresp,

	     axi4L_S_rdata,

	     axi4L_S_rready,

	     ip_enable,
	     RDY_ip_enable,

	     CLK_clock_for_app,
	     CLK_GATE_clock_for_app);
  input  CLK;
  input  RST_N;

  // action method axi4L_S_m_awvalid
  input  axi4L_S_awvalid;
  input  [31 : 0] axi4L_S_awaddr;
  input  [2 : 0] axi4L_S_awprot;

  // value method axi4L_S_m_awready
  output axi4L_S_awready;

  // action method axi4L_S_m_wvalid
  input  axi4L_S_wvalid;
  input  [31 : 0] axi4L_S_wdata;
  input  [3 : 0] axi4L_S_wstrb;

  // value method axi4L_S_m_wready
  output axi4L_S_wready;

  // value method axi4L_S_m_bvalid
  output axi4L_S_bvalid;

  // value method axi4L_S_m_bresp
  output [1 : 0] axi4L_S_bresp;

  // value method axi4L_S_m_buser

  // action method axi4L_S_m_bready
  input  axi4L_S_bready;

  // action method axi4L_S_m_arvalid
  input  axi4L_S_arvalid;
  input  [31 : 0] axi4L_S_araddr;
  input  [2 : 0] axi4L_S_arprot;

  // value method axi4L_S_m_arready
  output axi4L_S_arready;

  // value method axi4L_S_m_rvalid
  output axi4L_S_rvalid;

  // value method axi4L_S_m_rresp
  output [1 : 0] axi4L_S_rresp;

  // value method axi4L_S_m_rdata
  output [31 : 0] axi4L_S_rdata;

  // value method axi4L_S_m_ruser

  // action method axi4L_S_m_rready
  input  axi4L_S_rready;

  // value method ip_enable
  output ip_enable;
  output RDY_ip_enable;

  // oscillator and gates for output clock CLK_clock_for_app
  output CLK_clock_for_app;
  output CLK_GATE_clock_for_app;

  // signals for module outputs
  wire [31 : 0] axi4L_S_rdata;
  wire [1 : 0] axi4L_S_bresp, axi4L_S_rresp;
  wire CLK_GATE_clock_for_app,
       CLK_clock_for_app,
       RDY_ip_enable,
       axi4L_S_arready,
       axi4L_S_awready,
       axi4L_S_bvalid,
       axi4L_S_rvalid,
       axi4L_S_wready,
       ip_enable;


// Connecting DRM_Controller to DRM_Activator
wire wire_drm_to_uip_tready;
wire wire_drm_to_uip_tvalid;
wire [31:0] wire_drm_to_uip_tdata;
wire wire_uip_to_drm_tready;
wire wire_uip_to_drm_tvalid;
wire [31:0] wire_uip_to_drm_tdata;

top_drm_controller drm_controller
(

  .s_axi_aclk(CLK),
  .s_axi_arstn(RST_N),
  .s_axi_awready(axi4L_S_awready),
  .s_axi_awvalid(axi4L_S_awvalid),
  .s_axi_awaddr({16'h0, axi4L_S_awaddr[15:0]}),
  .s_axi_awprot(axi4L_S_awprot),
  .s_axi_wready(axi4L_S_wready),
  .s_axi_wvalid(axi4L_S_wvalid),
  .s_axi_wdata(axi4L_S_wdata),
  .s_axi_wstrb(axi4L_S_wstrb),
  .s_axi_bready(axi4L_S_bready),
  .s_axi_bvalid(axi4L_S_bvalid),
  .s_axi_bresp(axi4L_S_bresp),
  .s_axi_arready(axi4L_S_arready),
  .s_axi_arvalid(axi4L_S_arvalid),
  .s_axi_araddr({16'h0, axi4L_S_araddr[15:0]}),
  .s_axi_arprot(axi4L_S_arprot),
  .s_axi_rready(axi4L_S_rready),
  .s_axi_rvalid(axi4L_S_rvalid),
  .s_axi_rdata(axi4L_S_rdata),
  .s_axi_rresp(axi4L_S_rresp),
  
/*
// Chip DNA
.chip_dna_valid,
.chip_dna
*/

    .drm_aclk(CLK),
    .drm_arstn(RST_N),
    .drm_to_uip0_tready(wire_drm_to_uip_tready),
    .drm_to_uip0_tvalid(wire_drm_to_uip_tvalid),
    .drm_to_uip0_tdata (wire_drm_to_uip_tdata),
    .uip0_to_drm_tready(wire_uip_to_drm_tready),
    .uip0_to_drm_tvalid(wire_uip_to_drm_tvalid),
    .uip0_to_drm_tdata(wire_uip_to_drm_tdata)
      
);  

wire [127:0] activation_code;  

top_drm_activator_0x1058000200010001 drm_activator(
    
    .drm_aclk(CLK),
    .drm_arstn(RST_N),
    // AXI4-Stream Bus from DRM Controller
    .drm_to_uip_tready(wire_drm_to_uip_tready),
    .drm_to_uip_tvalid(wire_drm_to_uip_tvalid),
    .drm_to_uip_tdata(wire_drm_to_uip_tdata),
    // AXI4-Stream Bus to DRM Controller
    .uip_to_drm_tready(wire_uip_to_drm_tready),
    .uip_to_drm_tvalid(wire_uip_to_drm_tvalid),
    .uip_to_drm_tdata(wire_uip_to_drm_tdata),
    // IP core clock and reset
    .ip_core_aclk(CLK),
    // IP core interface
    .metering_event(1),
    .activation_code(activation_code)

);

  ip_activate ip_activate_1 (
    .activation_code(activation_code),
    .clk_in(CLK),
    .RDY_enable(RDY_ip_enable),
    .enable(ip_enable)
  );
endmodule  // mkDRM

